module m_actuatorline
contains
subroutine actuatorline(forceN,forceT,nx,ny,ipos,jpos,thetain,iradius,u,v,w,rho)
   use m_readinfile, only : p2l,uini,turbrpm,pitchangle,itiploss,tipspeedratio
   use mod_nrel5mw
   use m_nrelreadfoil
   use m_nrelliftdrag
   use m_bilin
   use m_turbines_print_blade

   implicit none
   integer, intent(in)    :: nx           ! dimension of horizontal axis of turbine plane (=ny from 3D grid)
   integer, intent(in)    :: ny           ! dimension of vertical   axis of turbine plane (=nz from 3D grid)
   integer, intent(in)    :: ipos         ! horizontal gridpoint for center of turbine
   integer, intent(in)    :: jpos         ! vertical   gridpoint for center of turbine


   real,    intent(in)    :: u(nx,ny)     ! u velocity through the turbine section
   real,    intent(in)    :: v(nx,ny)     ! v velocity at the turbine section
   real,    intent(in)    :: w(nx,ny)     ! w velocity at the turbine section
   real,    intent(in)    :: rho(nx,ny)   ! density at the turbine section
   real,    intent(in)    :: thetain      ! input rotation angle of blade one
   integer, intent(inout) :: iradius      ! number of gridpoints for blade length computed at first call
   real, intent(out) :: forceT(nrchords,3)  ! Tangential (driving force) along the blade
   real, intent(out) :: forceN(nrchords,3)  ! Nornal (drag force) along the blade



   real, parameter :: dx=1.0
   real, parameter :: pi=3.1415927410125732
   real, parameter :: pi2=2.0*pi
   real, parameter :: rad120=pi2*120.0/360.0

   real costheta
   real sintheta
   real x0,y0                             ! x-y location of turbine center
   real xb,yb                             ! x-y locatiuon along a blade
   real theta                             ! work blade rotation angle
   real q                                 ! Dynamic pressure
   real ux,vx,wx,dens                     ! local velocity and density variables
   real utheta                            ! tangential velocity from v and w
   real urel2                             ! relative velocity squared
   real, save :: radius                   ! turbine radius in grid cells
   integer i,j,k                          ! counters
   integer ic,jc                          ! gridpoint along a blade
   integer iblade                         ! blade counter
   real u0

   real phi                               ! Angle between rotorplane and relative velocity direction
   real cosphi(nrchords)
   real sinphi(nrchords)
   real clift(nrchords)                   ! Lift coefficient for each chord along the blade
   real cdrag(nrchords)                   ! Drag coefficient for each chord along the blade
   real forceL(nrchords,3)                  ! Lift force along the blade
   real forceD(nrchords,3)                  ! Drag force along the blade

! Lift and drag forces force(LD) per chord in Newton scaled by chord length (DC) to get Newton/meter.
   real fL(nrchords)
   real fD(nrchords)

! Tangential (rotational force) and normal (drag forces) f(TN) in N/m as in zho19a
   real fN(nrchords)
   real fT(nrchords)

! Non-dimensional tangent and normal  forces using asm20a scaling
   real fNa(nrchords)
   real fTa(nrchords)

   integer ichord                         ! chord counter
   integer, save :: ifirst=0

   real, save :: omega                    ! Rotation speed in radians per second
   real, save :: omegand                  ! Nondimensional rotation speed
   real newton,R
   real c1,c2,blades,frac,tiploss
   real, save :: g,lambda
   real :: denom, acos_arg
   real angattack                         ! computed angle of attack
   real angle                             ! work angle
   integer iave

   ifirst=ifirst+1

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! I N I T I A L I Z A T I O N   D O N E   A T   F I R S T   C A L L



   if (ifirst == 1) then
! Read lift and drag from foil data files
      call nrelreadfoil()

! Nondimensional turbine parameters
      relm=relm/p2l%length
      dc=dc/p2l%length
      chord=chord/p2l%length
      rotorradius=rotorradius/p2l%length
      hubradius=hubradius/p2l%length

! Blade length in number of gridpoints
      radius=rotorradius+hubradius     ! radius comes from mod_nrel5Mw
      R=2.0*radius                     ! rotor diameter
      iradius=nint(radius)             ! approximate radius in number of gridcells
      print '(a,f8.2,i4)','Rotor radius=   ',radius,iradius
      print '(a,f8.2)',   'Rotor diamenter=',R
      print '(a,50f8.2)', 'dc  :',dc(1:nrchords)
      print '(a,50f8.2)', 'relm:',relm(1:nrchords)
      print '(a,50f8.2)', 'chor:',chord(1:nrchords)

! Rotation speed in radians/s
      omega=pi2*turbrpm/60.0
! nondimesonal omega
      omegand=omega*p2l%time

      print *,'Omega  (RPM)                 =',turbrpm
      print *,'Omega  (radians/s)           =',omega
      print *,'Omega  (radians/)            =',omegand
      print *,'Time per revolution          =',pi2/omega
! Tipspeed(Tip speed can be determined from the rotational speed, which is ωR where ω is the rotational
! speed in radians per second and R is the radius of the turbine in meters.)
      print *,'tipspeed R*Omega m/s         =',real(iradius)*p2l%length*omega
! Tipspeed ratio 8 m/s winds (For three blades, a TSR of 6 to 7 is optimal. If it is less, not all
! the available energy is captured; if it is more, the blades move into an area of turbulence from the last
! blade and are not as efficient.

      lambda=radius*p2l%length*omega/(uini*p2l%vel)

! Prandtl-Glauert and Shen tip speed model
      if (itiploss == 2) then
         c1=0.125    ! coefficient 1
         c2=21.0     ! coefficient 2
         blades=3.0  ! Number of blades
         g=exp(-c1*(blades*lambda-c2))+0.1
      else
         g=1.0
      endif
   endif

! If given tipspeed ratio is larger than 0.0 we recompute the rotation speed to match the imposed tipspeed ratio
! based on the average velocity sampled on the circle with half a rotor radius.
   if (tipspeedratio > 0.0) then
      if (ifirst==1) print '(a)','Recomputing omega and lambda based on average  u velocity in rotor plane'
      u0=0.0
      iave=0
      do k=0,360,10
         angle=real(k)*pi2/360.0
         i=ipos+nint(real(iradius)*cos(angle)/2.0)
         j=jpos+nint(real(iradius)*sin(angle)/2.0)
         u0=u0+u(i,j)
         iave=iave+1
      enddo
      u0=u0/real(iave)
      omega=tipspeedratio*u0*p2l%vel/(radius*p2l%length)
      omegand=omega*p2l%time
      lambda=radius*p2l%length*omega/(u0*p2l%vel)
   else
      u0=uini
   endif

   if (ifirst==1) then
      print *
      print '(a)','**************************************'
      print '(a,2f8.2)','TIPSPEED RATIO R*Omega/uini  =',lambda,tipspeedratio
      print '(a,f8.2)','UINI                  (m/s)  =',u0*p2l%vel
      print '(a,f8.2)','omega                 (RPM)  =',omega*60.0/pi2
      print '(a)','**************************************'
      print *
   endif


! Prandtl-Glauert and Shen tip speed model (updated with new lambda)
      if (itiploss == 2) g=exp(-c1*(blades*lambda-c2))+0.1

! The given twist angles (in degrees) refers to zero angle a the tip, and then twists the blade as we
! move towards the hub from chord to chord. We store the twist angle for each chord in twist(:).
! Below we will calculate the angle between the relative velocity and the rotor plane as phi=atan2(ux,utheta).
! In addition there can be a user specified pitchangle.
! The local angle of attach, angattack, is then the difference between phi and the accumulated twist+pitch angles.

! Twist angle at tip
!      angle=atan(1.0/lambda)*360.0/pi2
!      print *,'tip relative angle',angle

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! C O M P U T I N G   T H E   B L A D E   F O R C E S
! Set rotation angle

! Center point of turbine
   x0=real(ipos)
   y0=real(jpos)

! Running through blades
   theta=thetain
   do iblade=1,3

      costheta=cos(theta)
      sintheta=sin(theta)

! Compute lift and drag force along blade
      do ichord=1,nrchords
         ! Finding pivot gridpoint index closest to chord number ichord to extract velocity
         xb=x0+relm(ichord)*costheta
         yb=y0+relm(ichord)*sintheta
         ic=int(xb)
         jc=int(yb)

! Bilinear interpolation, to find u(xb,yb), v(xb,yb), w(xb,yb) in the square  ic=int(xb), ic+1,  jc=int(yb), jc+1
! Non-dimensional velocity components from model
         call bilin(xb,yb,u,v,w,rho,ic,jc,nx,ny,ux,vx,wx,dens)

! Non-dimensional utheta (non-dim omegand and distance relm(ichord)
         utheta =  omegand*relm(ichord) - wx*costheta - vx*sintheta

! Non-dimensional urel**2
         urel2  = ux**2 + utheta**2

! Non-dimensional dynamic pressure
         q= 0.5 * dens * urel2

! Flowangle between relative windspeed and rotor plane
         phi = atan2(ux,utheta)
         sinphi(ichord)=sin(phi)
         cosphi(ichord)=cos(phi)

         angattack=(phi*360.0/pi2-twist(ichord)-pitchangle)
         call nrelliftdrag(clift,cdrag,angattack,ichord)

! Tip loss
         if (itiploss == 0) then
            tiploss=1.0
         else
            blades=3.0
            denom = 2.0*relm(ichord)*max(abs(sinphi(ichord)), 1.0e-6)
            frac = blades*(radius - relm(ichord)) / denom
            acos_arg = g * exp(-frac)
            if (acos_arg >  1.0) acos_arg =  1.0
            if (acos_arg < -1.0) acos_arg = -1.0
            tiploss = (2.0/pi) * acos(acos_arg)
         endif

! Non-dimensional lift and drag forces per blade element
         forceL(ichord,iblade) = q * chord(ichord) * dc(ichord) * clift(ichord) * tiploss
         forceD(ichord,iblade) = q * chord(ichord) * dc(ichord) * cdrag(ichord) * tiploss

         forceT(ichord,iblade) =forceL(ichord,iblade)*sinphi(ichord) - forceD(ichord,iblade)*cosphi(ichord)
         forceN(ichord,iblade) =forceL(ichord,iblade)*cosphi(ichord) + forceD(ichord,iblade)*sinphi(ichord)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Diagnostocs
         if (iblade == 1 .and. ifirst == 2000) then
         ! Lift and drag forces force(LD) per chord in Newton scaled by chord length (DC) to get Newton/meter.
            newton=(p2l%length**2)*p2l%rho*(p2l%vel**2)
            fL(ichord)=forceL(ichord,iblade)*newton/(dc(ichord)*p2l%length)
            fD(ichord)=forceD(ichord,iblade)*newton/(dc(ichord)*p2l%length)

         ! Tangential (rotational force) and normal (drag forces) f(TN) in N/m as in zho19a
            fT(ichord)=fL(ichord)*sinphi(ichord)  - fD(ichord)*cosphi(ichord)
            fN(ichord)=fL(ichord)*cosphi(ichord)  + fD(ichord)*sinphi(ichord)

         ! Non-dimensional tangent and normal  forces using asm20a scaling
            fTa(ichord)=fT(ichord)/(p2l%rho*(uini*p2l%vel)**2*radius*p2l%length)
            fNa(ichord)=fN(ichord)/(p2l%rho*(uini*p2l%vel)**2*radius*p2l%length)
         endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      enddo
      theta=theta+rad120
   enddo

   if (ifirst == 2000) then
      call turbines_print_blade(clift,cdrag,fL,fD,fN,fT,fTa,fNa,radius)
   endif

end subroutine
end module


