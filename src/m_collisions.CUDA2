module m_collisions
contains
attributes(global) subroutine collisions_kernel(f, feq, tau, nx, ny, nz, nl)
   implicit none
   integer, value :: nx, ny, nz, nl
   real, intent(in)    :: f(0:*,0:*,0:*,*)    ! HRR non-equilibrium distribution
   real, intent(inout) :: feq(0:*,0:*,0:*,*)  ! HRR equilibrium distribution
   real, intent(in)    :: tau(*)

   integer i, j, k, l
   integer idx, idy, idz

   ! Compute global thread indices
   idx = threadIdx%x + (blockIdx%x - 1) * blockDim%x
   idy = threadIdx%y + (blockIdx%y - 1) * blockDim%y
   idz = threadIdx%z + (blockIdx%z - 1) * blockDim%z

   ! Bounds check to ensure that threads are within the grid
   if (idx >= 1 .and. idx <= nx .and. idy >= 1 .and. idy <= ny .and. idz >= 1 .and. idz <= nz) then
      do l = 1, nl
         feq(idx, idy, idz, l) = feq(idx, idy, idz, l) + (1.0 - 1.0 / tau(idx, idy, idz)) * f(idx, idy, idz, l)
      end do
   end if
end subroutine collisions_kernel

subroutine collisions(f, feq, tau)
   use cudafor
   implicit none
   integer, parameter :: nx = 928          ! 928 resolution x-dir (east)
   integer, parameter :: ny = 96           ! resolution y-dir (north)
   integer, parameter :: nz = 96           ! resolution z-dir (up)
   integer, parameter :: nl = 27           ! number of components of D3Q27
   real, intent(in)    :: f(0:nx+1,0:ny+1,0:nz+1,nl)    ! HRR non-equilibrium distribution
   real, intent(inout) :: feq(0:nx+1,0:ny+1,0:nz+1,nl)  ! HRR equilibrium distribution
   real, intent(in)    :: tau(nx,ny,nz)


   integer, parameter :: threadsPerBlockX = 32
   integer, parameter :: threadsPerBlockY = 16
   integer, parameter :: threadsPerBlockZ = 4


   integer blocksPerGridX, blocksPerGridY, blocksPerGridZ

   ! Determine the number of blocks per grid in each dimension
   blocksPerGridX = (nx + threadsPerBlockX - 1) / threadsPerBlockX
   blocksPerGridY = (ny + threadsPerBlockY - 1) / threadsPerBlockY
   blocksPerGridZ = (nz + threadsPerBlockZ - 1) / threadsPerBlockZ

   ! Launch the CUDA kernel
   call collisions_kernel<<<dim3(blocksPerGridX, blocksPerGridY, blocksPerGridZ), dim3(threadsPerBlockX, threadsPerBlockY, threadsPerBlockZ)>>>(f, feq, tau, nx, ny, nz, nl)

   ! Synchronize to ensure kernel execution is complete
   call cudaDeviceSynchronize()
end subroutine collisions

end module

