module m_fequil3_kernel
contains

#ifdef _CUDA
   attributes(global)&
#endif
subroutine fequil3_kernel(feq, rho, u, v, w, nx, ny, nz, nl, H2, H3, cxs, cys, czs, cs2, weights, &
                          inv1cs2, inv2cs4, inv6cs6, ibgk)
#ifdef _CUDA
   use cudafor
#endif
   implicit none
   integer, value       :: nx, ny, nz, nl, ibgk
   real, intent(out)    :: feq(nl,nx+2,ny+2,nz+2)
   real, intent(in)     :: rho(nx,ny,nz)
   real, intent(in)     :: u(nx,ny,nz)
   real, intent(in)     :: v(nx,ny,nz)
   real, intent(in)     :: w(nx,ny,nz)
   real, intent(in)     :: H2(3,3,nl)
   real, intent(in)     :: H3(3,3,3,nl)
   integer, intent(in)  :: cxs(nl), cys(nl), czs(nl)
   real, intent(in)     :: cs2
   real, intent(in)     :: weights(nl)
   real, intent(in)     :: inv1cs2, inv2cs4, inv6cs6

   integer :: i,j,k,l,p,q,r,i1,j1,k1
   real :: vel(3), u2, cu
   real :: A0_2(3,3), A0_3(3,3,3)
   real :: tmp

#ifdef _CUDA
   attributes(device) :: feq, rho, u, v, w, H2, H3, cxs, cys, czs, weights
   i = threadIdx%x + (blockIdx%x - 1) * blockDim%x
   j = threadIdx%y + (blockIdx%y - 1) * blockDim%y
   k = threadIdx%z + (blockIdx%z - 1) * blockDim%z
   if (i > nx .or. j > ny .or. k > nz) return
#endif

#ifndef _CUDA
!$OMP PARALLEL DO collapse(3) private(i,j,k,l,p,q,r,i1,j1,k1,vel,u2,cu,tmp,A0_2,A0_3)
#endif
   do k=1,nz
   do j=1,ny
   do i=1,nx
      i1=i+1
      j1=j+1
      k1=k+1

      !--- macroscopic velocity ---
      vel(1)=u(i,j,k)
      vel(2)=v(i,j,k)
      vel(3)=w(i,j,k)
      u2 = vel(1)**2 + vel(2)**2 + vel(3)**2   ! |u|^2

      !--- First-order + quadratic term (linear in u, include -|u|^2/(2 cs2)) ---
      do l=1,nl
         cu = real(cxs(l))*vel(1) + real(cys(l))*vel(2) + real(czs(l))*vel(3)
         feq(l,i1,j1,k1) = rho(i,j,k) * weights(l) * (1.0 + cu*inv1cs2 + 0.5*(cu*cu)*inv2cs4 - 0.5*u2*inv1cs2)
      enddo

      !--- Second-order Hermite contribution (H2) ---
      A0_2(:,:) = 0.0
      do p=1,3
         do q=1,3
            A0_2(p,q) = rho(i,j,k) * vel(p) * vel(q) * inv2cs4
         enddo
      enddo

      do l=1,nl
         tmp = 0.0
         do p=1,3
            do q=1,3
               tmp = tmp + H2(p,q,l) * A0_2(p,q)
            enddo
         enddo
         feq(l,i1,j1,k1) = feq(l,i1,j1,k1) + weights(l) * tmp
      enddo

      !--- Third-order Hermite contribution (optional) ---
      if (ibgk == 3) then
         A0_3(:,:,:) = 0.0
         do p=1,3
            do q=1,3
               do r=1,3
                  A0_3(p,q,r) = rho(i,j,k) * vel(p)*vel(q)*vel(r) * inv6cs6
               enddo
            enddo
         enddo

         do l=1,nl
            tmp = 0.0
            do p=1,3
               do q=1,3
                  do r=1,3
                     tmp = tmp + H3(p,q,r,l) * A0_3(p,q,r)
                  enddo
               enddo
            enddo
            feq(l,i1,j1,k1) = feq(l,i1,j1,k1) + weights(l) * tmp
         enddo
      endif

   enddo
   enddo
   enddo
#ifndef _CUDA
!$OMP END PARALLEL DO
#endif

end subroutine
end module

