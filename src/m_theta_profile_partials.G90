module m_theta_profile_partials
implicit none
contains

!=====================================================================
! Kernel 1: Partial sums for each vertical level k
! Each thread processes ONE (i,j) location and accumulates into
! shared-memory partial sums per block.
!=====================================================================
#ifdef _CUDA
attributes(global) &
#endif
subroutine theta_profile_partials(temp, theta_part, n, isel1, isel2, jsel1, jsel2)
   use mod_dimensions, only : nx, ny, nz
#ifdef _CUDA
   use cudafor
#endif
   implicit none

   real, intent(in)    :: temp(n,0:nx+1,0:ny+1,0:nz+1)
   real, intent(inout) :: theta_part(0:nz+1)   ! per-block partials
   integer, value      :: n, isel1, isel2, jsel1, jsel2

#ifdef _CUDA
   integer :: i, j, k
   real :: val

   ! Determine which i,j this thread handles
   i = threadIdx%x + (blockIdx%x-1)*blockDim%x + isel1 - 1
   j = threadIdx%y + (blockIdx%y-1)*blockDim%y + jsel1 - 1

   if (i > isel2 .or. j > jsel2) return

   ! Loop over k and accumulate into global partial array via atomics
   do k = 1, nz
      val = temp(n,i,j,k)
      call atomicAdd(theta_part(k), val)
   end do
#endif

end subroutine
end module

