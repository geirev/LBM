!==============================================================
!  mod_turbines.F90
!  CPU/MPI-ready distributed actuator-line driver
!==============================================================
module mod_turbines
   use mod_dimensions, only : nx, ny, nz, nyg
!   use m_turbines_init
#ifdef MPI
   use mpi
   use m_mpi_decomp_init, only : mpi_rank, mpi_nprocs, j_start, j_end
#endif
   use mod_nrel5mw,  only : nrchords,relm,dc,chord,nfoil,twist
   use m_nrelreadfoil
   use m_nrelliftdrag

   implicit none
   real, parameter :: pi  = 3.14159265358979323846
   real, parameter :: pi2 = 2.0*pi

! For each turbine we store the following turbine information
   type turbine_t
      real    :: xhub             ! Turbine hub location in global grid
      real    :: yhub             ! Turbine hub location in global grid
      real    :: zhub             ! Turbine hub location in global grid
      real    :: radius           ! Turbine radius in non dimensional length
      integer :: iradius          ! Turbine radius in number of grid points
      integer :: nblades          ! Number of turbine blades
      integer :: nchords          ! Number of chords
      real    :: relm(nrchords)   ! relm is the location of the center point of a chord on the blade.
      real    :: dc(nrchords)     ! Chord length goes from relm(i)-dr(i)/2 to relm(i)+dr(i)/2 
      real    :: chord(nrchords)  ! Chord width
      real    :: twist(nrchords)  ! Blade twist for each chord
      integer :: nfoil(nrchords)  ! File number to read for lift and drag data
      real    :: theta            ! Rotor rotation angle
      real    :: yaw              ! Turbine yaw angle
      real    :: tilt             ! Turbine tilt angle
      real    :: omegand          ! nondimensional rotation speed, omega*p2l%time
      real    :: pitchangle       ! pitchangle
      integer :: tiploss          ! tiploss
   end type

! For each chord of each blade of each turbine we store the following (in the global grid)
   type :: point_t
      integer :: iturb   ! Turbine number
      integer :: iblade  ! Blade number
      integer :: ichord  ! Chord number
      real    :: xg      ! Global position of ichord point
      real    :: yg      ! Global position of ichord point
      real    :: zg      ! Global position of ichord point
      real    :: dc      ! 
      real    :: chord   ! 
      real    :: relm    ! 
      integer :: foil    ! 
      real    :: twist   ! Twist of chord ichord
      real    :: yaw     ! Turbine yaw (radians around z)
      real    :: tilt    ! Turbine tilt (radians in axis direction)
      real    :: theta   ! rotation angle of rotor (radians, zero up)
      real    :: pitch   ! pitch angle (radians)
      real    :: omegand ! nondimensional rotation speed, omega*p2l%time
   end type point_t

   type(turbine_t), allocatable :: turbines(:)
   type(point_t),   allocatable :: points_global(:)

   real                         :: F_turb(3,0:nx+1,0:ny+1,0:nz+1)
   real,            allocatable :: Fvec_points(:,:) ! (3, n_points)
   real,            allocatable :: Fvec_local(:,:)  ! (3, n_points)
   real,            allocatable :: Fvec_global(:,:) ! (3, n_points)
   integer :: ierr, np
#ifdef _CUDA
!   attributes(managed) :: F_turb
#endif

contains

!==============================================================
subroutine turbines_initialization()
   use mod_dimensions
   use m_readinfile, only : nturbines,p2l,ipos,jpos,kpos,turbrpm,pitchangle,tipspeedratio,itiploss
   use mod_D3Q27setup
   use mod_nrel5mw,  only : nrchords,hubradius,rotorradius
   implicit none
   real, save :: theta=0.0      ! start angle for turbine rotation
   integer :: n
   real :: radius
   real :: omega

   if (.not. allocated(turbines))  allocate(turbines(nturbines))

! Rotation speed in radians/s
   omega = pi2 * turbrpm / 60.0

   do n=1,nturbines
      turbines(n)%xhub   =real(ipos(n))
      turbines(n)%yhub   =real(jpos(n))
      turbines(n)%zhub   =real(kpos(n))

      radius  = rotorradius + hubradius
      turbines(n)%radius = radius/p2l%length
      turbines(n)%iradius = nint(turbines(n)%radius)             ! approximate radius in number of gridcells
      print '(a,f8.2,i4)','Rotor radius=   ',turbines(n)%radius, turbines(n)%iradius
      print '(a,f8.2)',   'Rotor diameter=',2.0*turbines(n)%radius

      turbines(n)%nblades= 3
      turbines(n)%nchords= nrchords
      turbines(n)%relm(1:nrchords)  = relm(1:nrchords)/p2l%length
      turbines(n)%dc(1:nrchords)    = dc(1:nrchords)/p2l%length
      turbines(n)%chord(1:nrchords) = chord(1:nrchords)/p2l%length
      turbines(n)%twist(1:nrchords) = twist(1:nrchords)
      turbines(n)%nfoil(1:nrchords) = nfoil(1:nrchords)
      turbines(n)%theta    = 0.0
      turbines(n)%yaw      = 0.0
      turbines(n)%tilt     = 0.0
      turbines(n)%omegand  = omega*p2l%time
      turbines(n)%pitchangle = pitchangle
      turbines(n)%tiploss  = itiploss
   enddo

   print *,'iradius=',turbines(1)%iradius
   call nrelreadfoil()
end subroutine turbines_initialization

!==============================================================
subroutine compute_actuator_forcing(F_turb, turbines, rho, u, v, w)
   use mod_dimensions
   use m_wtime
#ifdef MPI
   use mpi
   use m_mpi_decomp_init, only : mpi_rank
#endif
   implicit none

   ! Output: forcing field on this tile
   real, intent(inout) :: F_turb(3,0:nx+1,0:ny+1,0:nz+1)

   ! Inputs from main code
   type(turbine_t), intent(inout) :: turbines(:)
   real, intent(in) :: rho(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: u  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: v  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: w  (0:nx+1,0:ny+1,0:nz+1)
#ifdef _CUDA
   attributes(device) :: rho,u,v,w
#endif

   ! Locals
   type(point_t), allocatable :: points_global(:)
   real, allocatable :: Fvec_local(:,:), Fvec_global(:,:)
   real, allocatable :: rho_h(:,:,:), u_h(:,:,:), v_h(:,:,:), w_h(:,:,:)
   integer :: np_local
   integer, parameter :: icpu=2

   call cpustart()
   !-----------------------------
   ! 1. Update turbine azimuth
   !-----------------------------
   turbines(:)%theta = turbines(:)%theta + turbines(:)%omegand

   !-----------------------------
   ! 2. Compute actuator sample points
   !-----------------------------
   call distribute_actuator_points(turbines, points_global)
   np_local = size(points_global)

   if (np_local == 0) then
      F_turb = 0.0
      return
   end if

   !-----------------------------
   ! 3. Allocate force vectors
   !-----------------------------
   allocate(Fvec_local(3, np_local))
   allocate(Fvec_global(3, np_local))
   Fvec_local  = 0.0
   Fvec_global = 0.0
   call cpufinish(21)

   call cpustart()
   !-----------------------------
   ! 4. Host copies for CPU work
   !-----------------------------
   allocate(rho_h(0:nx+1,0:ny+1,0:nz+1))
   allocate(u_h  (0:nx+1,0:ny+1,0:nz+1))
   allocate(v_h  (0:nx+1,0:ny+1,0:nz+1))
   allocate(w_h  (0:nx+1,0:ny+1,0:nz+1))

   rho_h = rho
   u_h   = u
   v_h   = v
   w_h   = w

   !-----------------------------
   ! 5. Compute actuator point forces (local physics)
   !-----------------------------
   call actuatorline_point_forces(points_global, rho_h, u_h, v_h, w_h, Fvec_local, np_local)
   call cpufinish(22)

   call cpustart()
#ifdef MPI
   !-----------------------------
   ! 6. Combine forces from all ranks
   !-----------------------------
   call MPI_Allreduce(Fvec_local, Fvec_global, 3*np_local, MPI_REAL, MPI_SUM, MPI_COMM_WORLD, ierr)
#else
   Fvec_global = Fvec_local
#endif
   call cpufinish(23)

   call cpustart()
   !-----------------------------
   ! 7. Zero local forcing field
   !-----------------------------
   F_turb = 0.0

   !-----------------------------
   ! 8. Deposit smoothed forces
   !-----------------------------
   call actuatorline_deposit(F_turb, points_global, Fvec_global, np_local)

   ! Cleanup
   deallocate(Fvec_local, Fvec_global, rho_h, u_h, v_h, w_h)
   deallocate(points_global)

   call cpufinish(24)

end subroutine compute_actuator_forcing

!==============================================================
subroutine distribute_actuator_points(turbines, points_global)
   implicit none
   type(turbine_t),            intent(in)  :: turbines(:)
   type(point_t), allocatable, intent(out) :: points_global(:)

   integer :: it, ib, ic
   integer :: np_local
   real :: e_axis(3), e1(3), e2(3), e_rot(3)
   type(point_t) :: pt
   real :: theta, yaw, tilt

   allocate(points_global(0))
   np_local = 0

   do it = 1, size(turbines)
      yaw  = turbines(it)%yaw
      tilt = turbines(it)%tilt
      call rotor_basis(yaw, tilt, e_axis, e1, e2)

      do ib = 1, turbines(it)%nblades
         theta = turbines(it)%theta + real(ib-1)*pi2/real(turbines(it)%nblades)

         do ic = 1, turbines(it)%nchords
            pt%iturb  = it
            pt%iblade = ib
            pt%ichord = ic

            e_rot = cos(theta)*e1 + sin(theta)*e2

            pt%xg = turbines(it)%xhub + turbines(it)%relm(ic) * e_rot(1)
            pt%yg = turbines(it)%yhub + turbines(it)%relm(ic) * e_rot(2)
            pt%zg = turbines(it)%zhub + turbines(it)%relm(ic) * e_rot(3)

            pt%yaw     = yaw
            pt%tilt    = tilt
            pt%theta   = theta
            pt%relm    = turbines(it)%relm(ic)
            pt%dc      = turbines(it)%dc(ic)
            pt%chord   = turbines(it)%chord(ic)
            pt%twist   = turbines(it)%twist(ic)
            pt%pitch   = turbines(it)%pitchangle
            pt%foil    = turbines(it)%nfoil(ic)
            pt%omegand = turbines(it)%omegand

            call extend_array(points_global, np_local+1)
            np_local = np_local + 1
            points_global(np_local) = pt
         end do
      end do
   end do
end subroutine distribute_actuator_points

subroutine actuatorline_point_forces(points_global, rho, u, v, w, Fvec_local,np)
   use mod_dimensions
#ifdef MPI
   use m_mpi_decomp_init, only : j_start, j_end, mpi_rank
#endif
   implicit none
   type(point_t), intent(in) :: points_global(:)
   real, intent(in)          :: rho(:,:,:), u(:,:,:), v(:,:,:), w(:,:,:)
   integer, intent(in)       :: np
   real, intent(out)         :: Fvec_local(3, np)

   integer :: p, j0
   real :: ux,uy,uz,dens
   real :: angattack
   real :: clift,cdrag

   ! old-style local rotor-frame scalars
   real :: costheta, sintheta
   real :: utheta      ! tangential relative speed (Ωr minus flow tangential component)
   real :: phi         ! flow angle in rotor plane (radians)

   Fvec_local = 0.0

   do p = 1, np
      j0 = floor(points_global(p)%yg)
#ifdef MPI
      if (j0 < j_start .or. j0 > j_end) cycle
#endif

      ! Interpolate flow at blade point (already fixed)
      call interpolate_velocity(u,v,w,rho, &
           points_global(p)%xg, points_global(p)%yg, points_global(p)%zg, ux, uy, uz, dens)

      ! -----------------------------------------
      ! ORIGINAL angle-of-attack formulation
      ! -----------------------------------------
      costheta = cos(points_global(p)%theta)
      sintheta = sin(points_global(p)%theta)

      ! Tangential relative velocity component (as in your old routine):
      ! utheta = Ω r - (projection of flow onto tangential direction)
      utheta = points_global(p)%omegand * points_global(p)%relm  - &
               uz*costheta - uy*sintheta

      ! Flow angle phi: axial over tangential (same as original)
      phi    = atan2(ux, utheta)

      ! Angle of attack in degrees
      angattack = (phi*180.0/pi - points_global(p)%twist - points_global(p)%pitch)

      call nrelliftdrag(clift, cdrag, angattack, points_global(p)%foil)

      ! Compute blade force from axial & tangential components (ux, utheta)
      call compute_blade_force(Fvec_local(:,p), points_global(p), ux, utheta, dens, clift, cdrag)
   end do

   ! optional debug dump, unchanged
   if (mpi_rank == 0) then
      open(10,file='bladeforces0.dat')
         do p=1,np
            write(10,'(i4,6g13.5)') p, points_global(p)%xg, points_global(p)%yg, &
                                    points_global(p)%zg , Fvec_local(:,p)
         enddo
      close(10)
   elseif (mpi_rank == 1) then
      open(10,file='bladeforces1.dat')
         do p=1,np
            write(10,'(i4,6g13.5)') p, points_global(p)%xg, points_global(p)%yg, &
                                    points_global(p)%zg , Fvec_local(:,p)
         enddo
      close(10)
   endif

end subroutine actuatorline_point_forces
!==============================================================

!==============================================================
subroutine actuatorline_deposit(F_turb, points_global, Fvec_global, np)
   use mod_dimensions         ! nx, ny, nz, nyg
#ifdef MPI
   use m_mpi_decomp_init, only : j_start, j_end
#endif
   implicit none

   ! tile-local forcing array
   real, intent(inout) :: F_turb(3,0:nx+1,0:ny+1,0:nz+1)

   ! global blade points and their forces (after MPI_Allreduce)
   integer, intent(in)       :: np
   type(point_t), intent(in) :: points_global(np)
   real,          intent(in) :: Fvec_global(3, np)

   ! local variables
   integer :: p, i0, j0, k0
   integer :: ii, jj, kk
   integer :: ii1, ii2, jj1g, jj2g, kk1, kk2
   integer :: jj_local
   real    :: dx, dy, dz, weight, sumW
   real    :: sigma, epsilon
   real    :: xg, yg, zg
   real    :: Fp(3)
   integer :: krad

   ! Gaussian width (tuned: narrower than before to avoid overspread)
   epsilon = 2.0
   sigma   = epsilon / sqrt(2.0)
   krad = ceiling(3.0 * sigma)

   do p = 1, np

      ! ---------------------------------------------------------
      ! 1. Extract coordinates and the already-computed force
      ! ---------------------------------------------------------
      xg = points_global(p)%xg
      yg = points_global(p)%yg
      zg = points_global(p)%zg

      Fp(:) = Fvec_global(:,p)
      if (Fp(1) == 0.0 .and. Fp(2) == 0.0 .and. Fp(3) == 0.0) cycle

      ! nearest grid cell (global indices)
      i0 = floor(xg)
      j0 = floor(yg)
      k0 = floor(zg)

      ! ---------------------------------------------------------
      ! 2. Determine global smoothing stencil
      ! ---------------------------------------------------------

      ii1  = max(1,   i0 - krad)
      ii2  = min(nx,  i0 + krad)
      jj1g = max(1,   j0 - krad)
      jj2g = min(nyg, j0 + krad)
      kk1  = max(1,   k0 - krad)
      kk2  = min(nz,  k0 + krad)

      ! ---------------------------------------------------------
      ! 3. Compute normalization sumW over the entire global stencil
      ! ---------------------------------------------------------
      sumW = 0.0
      do kk = kk1, kk2
         dz = real(kk) - zg
         do jj = jj1g, jj2g
            dy = real(jj) - yg
            do ii = ii1, ii2
               dx = real(ii) - xg
               sumW = sumW + exp(-(dx*dx + dy*dy + dz*dz) / (2.0*sigma*sigma))
            end do
         end do
      end do

      if (sumW < 0.000001) cycle

      ! ---------------------------------------------------------
      ! 4. Deposit only in THIS TILE (j_start : j_end)
      ! ---------------------------------------------------------
      do kk = kk1, kk2
         dz = real(kk) - zg

         do jj = jj1g, jj2g

#ifdef MPI
            if (jj < j_start .or. jj > j_end) cycle
            jj_local = jj - j_start + 1
#else
            jj_local = jj
#endif
            if (jj_local < 1 .or. jj_local > ny) cycle

            dy = real(jj) - yg

            do ii = ii1, ii2
               dx = real(ii) - xg

               weight = (exp(-(dx*dx + dy*dy + dz*dz) / (2.0*sigma*sigma))) / sumW

               F_turb(1,ii,jj_local,kk) = F_turb(1,ii,jj_local,kk) + weight*Fp(1)
               F_turb(2,ii,jj_local,kk) = F_turb(2,ii,jj_local,kk) + weight*Fp(2)
               F_turb(3,ii,jj_local,kk) = F_turb(3,ii,jj_local,kk) + weight*Fp(3)

            end do
         end do
      end do

   end do

end subroutine actuatorline_deposit

!==============================================================
subroutine rotor_basis(yaw, tilt, e_axis, e1, e2)
! Build orthonormal rotor basis for given yaw and tilt (radians)
!  yaw=0.0 and tilt=0.0 gives
!  e_axis(1,0,0)
!      e1(0,1,0)
!      e2(0,0,1)
   implicit none
   real, intent(in)  :: yaw, tilt
   real, intent(out) :: e_axis(3), e1(3), e2(3)
   e_axis = (/ cos(yaw)*cos(tilt),  sin(yaw)*cos(tilt), -sin(tilt) /)
   e1     = (/ -sin(yaw),          cos(yaw),            0.0       /)
   e2     = (/ -cos(yaw)*sin(tilt),-sin(yaw)*sin(tilt),-cos(tilt) /)
end subroutine rotor_basis

!==============================================================
subroutine interpolate_velocity(u,v,w,rho,xg,yg,zg,ux,uy,uz,dens)
   use mod_dimensions
#ifdef MPI
   use m_mpi_decomp_init, only : j_start, j_end
#endif
   implicit none

   real, intent(in) :: u(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: v(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: w(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: rho(0:nx+1,0:ny+1,0:nz+1)

   real, intent(in)  :: xg, yg, zg     ! global coordinates
   real, intent(out) :: ux, uy, uz, dens

   integer :: ig, jg, kg              ! global indices
   integer :: i,  j,  k               ! local indices
   real :: fx, fy, fz
   real :: c000,c100,c010,c110,c001,c101,c011,c111

   !-----------------------------------------------
   ! 1. Integer global indices
   !-----------------------------------------------
   ig = floor(xg)
   jg = floor(yg)
   kg = floor(zg)

   !-----------------------------------------------
   ! 2. Fractional offsets (ALWAYS subtract global index)
   !-----------------------------------------------
   fx = xg - real(ig)
   fy = yg - real(jg)
   fz = zg - real(kg)

   !-----------------------------------------------
   ! 3. Convert global j to local tile index
   !-----------------------------------------------
#ifdef MPI
   j = jg - j_start + 1               ! local tile index 1..ny
#else
   j = jg                             ! no MPI → local == global
#endif
   i = ig
   k = kg

   !-----------------------------------------------
   ! 4. Clamp to interior domain for interpolation
   !-----------------------------------------------
   i = max(1, min(nx-1, i))
   j = max(1, min(ny-1, j))
   k = max(1, min(nz-1, k))

   !-----------------------------------------------
   ! 5. Interpolate u-component
   !-----------------------------------------------
   c000=u(i,j,k);   c100=u(i+1,j,k);     c010=u(i,j+1,k);     c110=u(i+1,j+1,k)
   c001=u(i,j,k+1); c101=u(i+1,j,k+1);   c011=u(i,j+1,k+1);   c111=u(i+1,j+1,k+1)
   ux = trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)

   ! v
   c000=v(i,j,k);   c100=v(i+1,j,k);     c010=v(i,j+1,k);     c110=v(i+1,j+1,k)
   c001=v(i,j,k+1); c101=v(i+1,j,k+1);   c011=v(i,j+1,k+1);   c111=v(i+1,j+1,k+1)
   uy = trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)

   ! w
   c000=w(i,j,k);   c100=w(i+1,j,k);     c010=w(i,j+1,k);     c110=w(i+1,j+1,k)
   c001=w(i,j,k+1); c101=w(i+1,j,k+1);   c011=w(i,j+1,k+1);   c111=w(i+1,j+1,k+1)
   uz = trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)

   ! rho
   c000=rho(i,j,k);   c100=rho(i+1,j,k);   c010=rho(i,j+1,k);   c110=rho(i+1,j+1,k)
   c001=rho(i,j,k+1); c101=rho(i+1,j,k+1); c011=rho(i,j+1,k+1); c111=rho(i+1,j+1,k+1)
   dens = trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)

end subroutine interpolate_velocity

!==============================================================
pure function trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz) result(val)
   real, intent(in) :: c000,c100,c010,c110,c001,c101,c011,c111
   real, intent(in) :: fx,fy,fz
   real :: val
   val = c000*(1-fx)*(1-fy)*(1-fz) + c100*fx*(1-fy)*(1-fz) + &
         c010*(1-fx)*fy*(1-fz)     + c110*fx*fy*(1-fz)     + &
         c001*(1-fx)*(1-fy)*fz     + c101*fx*(1-fy)*fz     + &
         c011*(1-fx)*fy*fz         + c111*fx*fy*fz
end function trilinear

!==============================================================

subroutine compute_blade_force(Fvec, point, u_ax, u_tan_rel, dens, cl, cd)
   implicit none
   type(point_t), intent(in) :: point
   real, intent(in)          :: u_ax         ! axial component (≈ ux)
   real, intent(in)          :: u_tan_rel    ! tangential relative component (uth)
   real, intent(in)          :: dens
   real, intent(in)          :: cl, cd
   real, intent(out)         :: Fvec(3)

   ! rotor basis
   real :: e_axis(3), e1(3), e2(3)
   real :: e_rot(3), e_tan(3)

   real :: speed2
   real :: L, D, phi, sinphi, cosphi
   real :: area, tiploss

   ! Build rotor coordinate system
   call rotor_basis(point%yaw, point%tilt, e_axis, e1, e2)
   e_rot =  cos(point%theta)*e1 + sin(point%theta)*e2   ! radial
   e_tan = -sin(point%theta)*e1 + cos(point%theta)*e2   ! tangential

   ! Relative speed squared in rotor plane (same scalars as in AoA)
   speed2 = u_ax*u_ax + u_tan_rel*u_tan_rel

   ! Projected area (chord x radial segment)
   area = point%chord * point%dc

   tiploss = 1.0   ! placeholder for future Prandtl correction

   L = 0.5 * dens * speed2 * cl * area * tiploss
   D = 0.5 * dens * speed2 * cd * area * tiploss

   ! Flow angle in rotor plane — MUST match what was used for AoA:
   phi = atan2(u_ax, u_tan_rel)
   sinphi = sin(phi)
   cosphi = cos(phi)

   ! Lift perpendicular to relative velocity; drag opposite to it
   !
   ! Tangential/axial basis: e_axis (axial), e_tan (tangential)
   !
   ! Relative velocity direction vector (unnormalized) is:
   !   u_rel_dir ∝ u_ax * e_axis + u_tan_rel * e_tan
   !
   ! We decompose lift/drag in the (e_axis, e_tan) plane using phi.
   Fvec = L * (cosphi * e_axis + sinphi * e_tan) - &
          D * (sinphi * e_axis - cosphi * e_tan)

end subroutine compute_blade_force
!==============================================================

!==============================================================
subroutine extend_array(arr, n)
! Utility: grow allocatable array to size n
   type(point_t), allocatable, intent(inout) :: arr(:)
   integer, intent(in) :: n
   type(point_t), allocatable :: tmp(:)
   integer :: old

   if (.not.allocated(arr)) then
      allocate(arr(n))
   else
      allocate(tmp(n))
      old = size(arr)
      tmp(1:old) = arr(1:old)
      call move_alloc(tmp, arr)
   end if
end subroutine extend_array

!==============================================================
end module mod_turbines

