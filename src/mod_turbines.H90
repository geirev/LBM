!==============================================================
!  mod_turbines.F90
!  CPU/MPI/GPU-ready distributed actuator-line driver
!==============================================================
module mod_turbines
   use mod_dimensions, only : nx, ny, nz, nyg
#ifdef MPI
   use mpi
   use m_mpi_decomp_init, only : mpi_rank, mpi_nprocs, j_start, j_end
#endif
   use mod_nrel5mw,   only : nrchords, relm, dc, chord, nfoil, twist, hubradius, rotorradius
   use m_nrelreadfoil
   use m_nrelliftdrag

   implicit none
   real, parameter :: pi  = 3.14159265358979323846
   real, parameter :: pi2 = 2.0*pi

   !-----------------------------------------------------------
   ! Turbine and actuator-point types
   !-----------------------------------------------------------
   type turbine_t
      real    :: xhub             ! hub x-position (global grid)
      real    :: yhub             ! hub y-position (global grid)
      real    :: zhub             ! hub z-position (global grid)
      real    :: radius           ! rotor radius (non-dim, /p2l%length)
      integer :: iradius          ! rotor radius in grid cells
      integer :: nblades          ! number of blades
      integer :: nchords          ! chords per blade
      real    :: relm(nrchords)   ! radial positions (non-dim)
      real    :: dc(nrchords)     ! radial segment size (non-dim)
      real    :: chord(nrchords)  ! chord width (non-dim)
      real    :: twist(nrchords)  ! twist angle per chord (deg)
      integer :: nfoil(nrchords)  ! index to foil table
      real    :: theta            ! rotor azimuth (rad)
      real    :: yaw              ! yaw angle (rad)
      real    :: tilt             ! tilt angle (rad)
      real    :: omegand          ! non-dim angular speed, ω * p2l%time
      real    :: pitchangle       ! collective pitch (deg)
      integer :: tiploss          ! tip-loss flag
   end type turbine_t

   type :: point_t
      integer :: iturb            ! turbine index
      integer :: iblade           ! blade index
      integer :: ichord           ! chord index
      real    :: xg, yg, zg       ! global coordinates of sample point
      real    :: dc               ! local radial segment
      real    :: chord            ! local chord width
      real    :: relm             ! local radial position
      integer :: foil             ! foil index
      real    :: twist            ! local twist
      real    :: yaw, tilt        ! turbine yaw/tilt (rad)
      real    :: theta            ! rotor azimuth (rad)
      real    :: pitch            ! pitch (deg)
      real    :: omegand          ! non-dim angular speed
   end type point_t

   ! Module storage
   type(turbine_t), allocatable :: turbines(:)
   type(point_t),   allocatable :: points_global(:)

   real                         :: F_turb(3,0:nx+1,0:ny+1,0:nz+1)
   real,            allocatable :: Fvec_local(:,:)   ! (3,np)
   real,            allocatable :: Fvec_global(:,:)  ! (3,np)

   integer :: ierr

contains
!==============================================================
subroutine turbines_initialization()
   use m_readinfile, only : nturbines, p2l, ipos, jpos, kpos, turbrpm, pitchangle, tipspeedratio, itiploss
   implicit none
   integer :: n
   real    :: radius, omega

   if (.not. allocated(turbines))  allocate(turbines(nturbines))

   ! rotation speed in rad/s
   omega = pi2 * turbrpm / 60.0

   do n = 1, nturbines
      turbines(n)%xhub   = real(ipos(n))
      turbines(n)%yhub   = real(jpos(n))
      turbines(n)%zhub   = real(kpos(n))

      radius              = rotorradius + hubradius
      turbines(n)%radius  = radius / p2l%length
      turbines(n)%iradius = nint(turbines(n)%radius)

      print '(a,f8.2,i4)', 'Rotor radius=   ', turbines(n)%radius, turbines(n)%iradius
      print '(a,f8.2)',    'Rotor diameter=', 2.0 * turbines(n)%radius

      turbines(n)%nblades      = 3
      turbines(n)%nchords      = nrchords
      turbines(n)%relm(1: )    = relm(1: )   / p2l%length
      turbines(n)%dc(1: )      = dc(1: )     / p2l%length
      turbines(n)%chord(1: )   = chord(1: )  / p2l%length
      turbines(n)%twist(1: )   = twist(1: )
      turbines(n)%nfoil(1: )   = nfoil(1: )
      turbines(n)%theta        = 0.0
      turbines(n)%yaw          = 0.0
      turbines(n)%tilt         = 0.0
      turbines(n)%omegand      = omega * p2l%time
      turbines(n)%pitchangle   = pitchangle
      turbines(n)%tiploss      = itiploss
   end do

   print *, 'iradius=', turbines(1)%iradius
   call nrelreadfoil()
end subroutine turbines_initialization

!==============================================================
subroutine compute_actuator_forcing(F_turb, turbines, rho, u, v, w)
   use m_wtime
#ifdef MPI
   use m_mpi_decomp_init, only : mpi_rank, j_start, j_end
#endif
   implicit none

   real,          intent(inout) :: F_turb(3,0:nx+1,0:ny+1,0:nz+1)
   type(turbine_t), intent(inout) :: turbines(:)
   real, intent(in) :: rho(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: u  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: v  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: w  (0:nx+1,0:ny+1,0:nz+1)

   type(point_t), allocatable :: points(:)
   real, allocatable          :: rho_h(:,:,:), u_h(:,:,:), v_h(:,:,:), w_h(:,:,:)
   integer                    :: np_local

   call cpustart()

   ! 1. update azimuth
   turbines(:)%theta = turbines(:)%theta + turbines(:)%omegand

   ! 2. global actuator points
   call distribute_actuator_points(turbines, points)
   np_local = size(points)

   if (np_local == 0) then
      F_turb = 0.0
      return
   end if

   ! 3. allocate force vectors
   allocate(Fvec_local(3, np_local))
   allocate(Fvec_global(3, np_local))
   Fvec_local  = 0.0
   Fvec_global = 0.0
   call cpufinish(21)

   call cpustart()
#ifdef _CUDA
   ! 4–5. GPU: compute point forces directly
   call actuatorline_point_forces_gpu(points, rho, u, v, w, Fvec_local, np_local)
#else
   ! 4. host copies
   allocate(rho_h(0:nx+1,0:ny+1,0:nz+1))
   allocate(u_h  (0:nx+1,0:ny+1,0:nz+1))
   allocate(v_h  (0:nx+1,0:ny+1,0:nz+1))
   allocate(w_h  (0:nx+1,0:ny+1,0:nz+1))

   rho_h = rho
   u_h   = u
   v_h   = v
   w_h   = w

   ! 5. CPU point forces
   call actuatorline_point_forces(points, rho_h, u_h, v_h, w_h, Fvec_local, np_local)

   deallocate(rho_h, u_h, v_h, w_h)
#endif
   call cpufinish(22)

   call cpustart()
#ifdef MPI
   ! 6. global sum over tiles
   call MPI_Allreduce(Fvec_local, Fvec_global, 3*np_local, MPI_REAL, MPI_SUM, MPI_COMM_WORLD, ierr)
#else
   Fvec_global = Fvec_local
#endif
   call cpufinish(23)

   call cpustart()
   ! 7. clear forcing field
   F_turb = 0.0

   ! 8. deposit smoothed forces on this tile
   call actuatorline_deposit(F_turb, points, Fvec_global, np_local)

   deallocate(Fvec_local, Fvec_global)
   deallocate(points)

   call cpufinish(24)
end subroutine compute_actuator_forcing

!==============================================================
subroutine distribute_actuator_points(turbines, points_global)
   implicit none
   type(turbine_t),            intent(in)  :: turbines(:)
   type(point_t), allocatable, intent(out) :: points_global(:)

   integer :: it, ib, ic
   integer :: np_local
   real    :: e_axis(3), e1(3), e2(3), e_rot(3)
   real    :: theta, yaw, tilt
   type(point_t) :: pt

   allocate(points_global(0))
   np_local = 0

   do it = 1, size(turbines)
      yaw  = turbines(it)%yaw
      tilt = turbines(it)%tilt
      call rotor_basis(yaw, tilt, e_axis, e1, e2)

      do ib = 1, turbines(it)%nblades
         theta = turbines(it)%theta + real(ib-1)*pi2/real(turbines(it)%nblades)

         do ic = 1, turbines(it)%nchords
            pt%iturb  = it
            pt%iblade = ib
            pt%ichord = ic

            e_rot = cos(theta)*e1 + sin(theta)*e2

            pt%xg = turbines(it)%xhub + turbines(it)%relm(ic) * e_rot(1)
            pt%yg = turbines(it)%yhub + turbines(it)%relm(ic) * e_rot(2)
            pt%zg = turbines(it)%zhub + turbines(it)%relm(ic) * e_rot(3)

            pt%yaw     = yaw
            pt%tilt    = tilt
            pt%theta   = theta
            pt%relm    = turbines(it)%relm(ic)
            pt%dc      = turbines(it)%dc(ic)
            pt%chord   = turbines(it)%chord(ic)
            pt%twist   = turbines(it)%twist(ic)
            pt%pitch   = turbines(it)%pitchangle
            pt%foil    = turbines(it)%nfoil(ic)
            pt%omegand = turbines(it)%omegand

            call extend_array(points_global, np_local+1)
            np_local = np_local + 1
            points_global(np_local) = pt
         end do
      end do
   end do
end subroutine distribute_actuator_points

!==============================================================
subroutine actuatorline_point_forces(points_global, rho, u, v, w, Fvec_local, np)
   use m_nrelliftdrag
#ifdef MPI
   use m_mpi_decomp_init, only : j_start, j_end, mpi_rank
#endif
   implicit none
   type(point_t), intent(in) :: points_global(:)
   real, intent(in) :: rho(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: u  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: v  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: w  (0:nx+1,0:ny+1,0:nz+1)
   integer, intent(in) :: np
   real,    intent(out):: Fvec_local(3, np)

   integer :: p, j0
   real :: ux, uy, uz, dens
   real :: angattack, clift, cdrag
   real :: costheta, sintheta
   real :: utheta, phi

   Fvec_local = 0.0

   do p = 1, np
      j0 = floor(points_global(p)%yg)
#ifdef MPI
      if (j0 < j_start .or. j0 > j_end) cycle
      call interpolate_velocity(u, v, w, rho, &
           points_global(p)%xg, points_global(p)%yg, points_global(p)%zg, &
           j_start, ux, uy, uz, dens)
#else
      call interpolate_velocity(u, v, w, rho, &
           points_global(p)%xg, points_global(p)%yg, points_global(p)%zg, &
           1, ux, uy, uz, dens)
#endif

      costheta = cos(points_global(p)%theta)
      sintheta = sin(points_global(p)%theta)

      utheta = points_global(p)%omegand * points_global(p)%relm - &
               uz*costheta - uy*sintheta

      phi    = atan2(ux, utheta)
      angattack = (phi*180.0/pi - points_global(p)%twist - points_global(p)%pitch)

      call nrelliftdrag(clift, cdrag, angattack, points_global(p)%foil)

      call compute_blade_force(Fvec_local(:,p), points_global(p), ux, utheta, dens, clift, cdrag)
   end do
end subroutine actuatorline_point_forces

!==============================================================
#ifdef _CUDA
subroutine actuatorline_point_forces_gpu(points_global, rho, u, v, w, Fvec_local, np)
   use cudafor
#ifdef MPI
   use m_mpi_decomp_init, only : j_start, j_end, mpi_rank
#else
   integer, parameter :: j_start = 1, j_end = ny
#endif
   implicit none

   type(point_t), intent(in) :: points_global(:)
   real, intent(in)          :: rho(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in)          :: u  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in)          :: v  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in)          :: w  (0:nx+1,0:ny+1,0:nz+1)
   integer, intent(in)       :: np
   real, intent(out)         :: Fvec_local(3, np)

   type(point_t), device, allocatable :: points_d(:)
   real,          device, allocatable :: Fvec_d(:,:)

   integer :: tpb, nblocks, istat

   if (np <= 0) then
      Fvec_local = 0.0
      return
   end if

   allocate(points_d(np))
   points_d = points_global

   allocate(Fvec_d(3,np))
   Fvec_d = 0.0

   tpb     = 128
   nblocks = (np + tpb - 1) / tpb

   call actuatorline_point_forces_kernel<<<nblocks, tpb>>> &
        (points_d, np, rho, u, v, w, j_start, j_end, Fvec_d)

   istat = cudaDeviceSynchronize()

   Fvec_local = Fvec_d

   deallocate(points_d, Fvec_d)
end subroutine actuatorline_point_forces_gpu
#endif  /* _CUDA */

!==============================================================
subroutine actuatorline_deposit(F_turb, points_global, Fvec_global, np)
#ifdef MPI
   use m_mpi_decomp_init, only : j_start, j_end
#endif
   implicit none

   real,          intent(inout) :: F_turb(3,0:nx+1,0:ny+1,0:nz+1)
   integer,       intent(in)    :: np
   type(point_t), intent(in)    :: points_global(np)
   real,          intent(in)    :: Fvec_global(3, np)

   integer :: p, i0, j0, k0
   integer :: ii, jj, kk
   integer :: ii1, ii2, jj1g, jj2g, kk1, kk2
   integer :: jj_local
   real    :: dx, dy, dz, weight, sumW
   real    :: sigma, epsilon
   real    :: xg, yg, zg
   real    :: Fp(3)
   integer :: krad

   epsilon = 2.0
   sigma   = epsilon / sqrt(2.0)
   krad    = ceiling(3.0 * sigma)

   do p = 1, np
      xg = points_global(p)%xg
      yg = points_global(p)%yg
      zg = points_global(p)%zg

      Fp(:) = Fvec_global(:,p)
      if (Fp(1) == 0.0 .and. Fp(2) == 0.0 .and. Fp(3) == 0.0) cycle

      i0 = floor(xg)
      j0 = floor(yg)
      k0 = floor(zg)

      ii1  = max(1,   i0 - krad)
      ii2  = min(nx,  i0 + krad)
      jj1g = max(1,   j0 - krad)
      jj2g = min(nyg, j0 + krad)
      kk1  = max(1,   k0 - krad)
      kk2  = min(nz,  k0 + krad)

      sumW = 0.0
      do kk = kk1, kk2
         dz = real(kk) - zg
         do jj = jj1g, jj2g
            dy = real(jj) - yg
            do ii = ii1, ii2
               dx = real(ii) - xg
               sumW = sumW + exp(-(dx*dx + dy*dy + dz*dz)/(2.0*sigma*sigma))
            end do
         end do
      end do

      if (sumW < 1.0e-6) cycle

      do kk = kk1, kk2
         dz = real(kk) - zg
         do jj = jj1g, jj2g
#ifdef MPI
            if (jj < j_start .or. jj > j_end) cycle
            jj_local = jj - j_start + 1
#else
            jj_local = jj
#endif
            if (jj_local < 1 .or. jj_local > ny) cycle

            dy = real(jj) - yg

            do ii = ii1, ii2
               dx = real(ii) - xg

               weight = exp(-(dx*dx + dy*dy + dz*dz)/(2.0*sigma*sigma)) / sumW

               F_turb(1,ii,jj_local,kk) = F_turb(1,ii,jj_local,kk) + weight*Fp(1)
               F_turb(2,ii,jj_local,kk) = F_turb(2,ii,jj_local,kk) + weight*Fp(2)
               F_turb(3,ii,jj_local,kk) = F_turb(3,ii,jj_local,kk) + weight*Fp(3)
            end do
         end do
      end do
   end do
end subroutine actuatorline_deposit

!==============================================================
#ifdef _CUDA
attributes(global) &
#endif
subroutine actuatorline_point_forces_kernel(points, np, rho, u, v, w, j_start, j_end, Fvec)
   use m_nrelliftdrag
   implicit none

   type(point_t) :: points(:)
   integer, value :: np
   real :: rho(0:nx+1,0:ny+1,0:nz+1)
   real :: u  (0:nx+1,0:ny+1,0:nz+1)
   real :: v  (0:nx+1,0:ny+1,0:nz+1)
   real :: w  (0:nx+1,0:ny+1,0:nz+1)
   integer, value :: j_start, j_end
   real :: Fvec(3, np)

   integer :: p, j0
   real :: ux, uy, uz, dens
   real :: angattack, clift, cdrag
   real :: costheta, sintheta
   real :: utheta, phi

#ifdef _CUDA
   p = (blockIdx%x - 1) * blockDim%x + threadIdx%x
#else
   p = 0   ! should never be used without CUDA; dummy
#endif
   if (p < 1 .or. p > np) return

   j0 = floor(points(p)%yg)
   if (j0 < j_start .or. j0 > j_end) then
      Fvec(1,p) = 0.0
      Fvec(2,p) = 0.0
      Fvec(3,p) = 0.0
      return
   end if

   call interpolate_velocity(u, v, w, rho, &
        points(p)%xg, points(p)%yg, points(p)%zg, j_start, ux, uy, uz, dens)

   costheta = cos(points(p)%theta)
   sintheta = sin(points(p)%theta)

   utheta = points(p)%omegand * points(p)%relm - &
            uz*costheta - uy*sintheta

   phi = atan2(ux, utheta)

   angattack = (phi*180.0/pi - points(p)%twist - points(p)%pitch)

   call nrelliftdrag(clift, cdrag, angattack, points(p)%foil)

   call compute_blade_force(Fvec(:,p), points(p), ux, utheta, dens, clift, cdrag)
end subroutine actuatorline_point_forces_kernel

!==============================================================
#ifdef _CUDA
attributes(host,device) &
#endif
real function trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)
   implicit none
   real, intent(in) :: c000,c100,c010,c110,c001,c101,c011,c111
   real, intent(in) :: fx,fy,fz

   trilinear = c000*(1-fx)*(1-fy)*(1-fz) + c100*fx*(1-fy)*(1-fz) + &
               c010*(1-fx)*fy*(1-fz)     + c110*fx*fy*(1-fz)     + &
               c001*(1-fx)*(1-fy)*fz     + c101*fx*(1-fy)*fz     + &
               c011*(1-fx)*fy*fz         + c111*fx*fy*fz
end function trilinear

!==============================================================
#ifdef _CUDA
attributes(host,device) &
#endif
subroutine rotor_basis(yaw, tilt, e_axis, e1, e2)
   implicit none
   real, intent(in)  :: yaw, tilt
   real, intent(out) :: e_axis(3), e1(3), e2(3)

   e_axis = (/ cos(yaw)*cos(tilt),  sin(yaw)*cos(tilt), -sin(tilt) /)
   e1     = (/ -sin(yaw),           cos(yaw),            0.0       /)
   e2     = (/ -cos(yaw)*sin(tilt), -sin(yaw)*sin(tilt), -cos(tilt) /)
end subroutine rotor_basis

!==============================================================
#ifdef _CUDA
attributes(host,device) &
#endif
subroutine compute_blade_force(Fvec, point, u_ax, u_tan_rel, dens, cl, cd)
   implicit none
   type(point_t), intent(in) :: point
   real, intent(in)          :: u_ax, u_tan_rel
   real, intent(in)          :: dens
   real, intent(in)          :: cl, cd
   real, intent(out)         :: Fvec(3)

   real :: e_axis(3), e1(3), e2(3)
   real :: e_rot(3), e_tan(3)
   real :: speed2, area, L, D
   real :: phi, sinphi, cosphi
   real :: tiploss

   call rotor_basis(point%yaw, point%tilt, e_axis, e1, e2)

   e_rot =  cos(point%theta)*e1 + sin(point%theta)*e2
   e_tan = -sin(point%theta)*e1 + cos(point%theta)*e2

   speed2 = u_ax*u_ax + u_tan_rel*u_tan_rel
   area   = point%chord * point%dc
   tiploss = 1.0

   L = 0.5 * dens * speed2 * cl * area * tiploss
   D = 0.5 * dens * speed2 * cd * area * tiploss

   phi    = atan2(u_ax, u_tan_rel)
   sinphi = sin(phi)
   cosphi = cos(phi)

   Fvec = L * (cosphi * e_axis + sinphi * e_tan) - &
          D * (sinphi * e_axis - cosphi * e_tan)
end subroutine compute_blade_force

!==============================================================
subroutine extend_array(arr, n)
   type(point_t), allocatable, intent(inout) :: arr(:)
   integer, intent(in) :: n
   type(point_t), allocatable :: tmp(:)
   integer :: old

   if (.not.allocated(arr)) then
      allocate(arr(n))
   else
      allocate(tmp(n))
      old = size(arr)
      tmp(1:old) = arr(1:old)
      call move_alloc(tmp, arr)
   end if
end subroutine extend_array

!==============================================================
#ifdef _CUDA
attributes(host,device) &
#endif
subroutine interpolate_velocity(u,v,w,rho, xg,yg,zg, j_start, ux,uy,uz,dens)
   use mod_dimensions
   implicit none

   real, intent(in) :: u  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: v  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: w  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: rho(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: xg, yg, zg
   integer, value   :: j_start
   real, intent(out):: ux, uy, uz, dens

   integer :: ig, jg, kg
   integer :: i, j, k
   real    :: fx, fy, fz
   real    :: c000,c100,c010,c110,c001,c101,c011,c111

   ig = floor(xg)
   jg = floor(yg)
   kg = floor(zg)

   fx = xg - real(ig)
   fy = yg - real(jg)
   fz = zg - real(kg)

   j = jg - j_start + 1
   i = ig
   k = kg

   i = max(1, min(nx-1, i))
   j = max(1, min(ny-1, j))
   k = max(1, min(nz-1, k))

   c000=u(i,j,k);   c100=u(i+1,j,k);   c010=u(i,j+1,k);   c110=u(i+1,j+1,k)
   c001=u(i,j,k+1); c101=u(i+1,j,k+1); c011=u(i,j+1,k+1); c111=u(i+1,j+1,k+1)
   ux = trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)

   c000=v(i,j,k);   c100=v(i+1,j,k);   c010=v(i,j+1,k);   c110=v(i+1,j+1,k)
   c001=v(i,j,k+1); c101=v(i+1,j,k+1); c011=v(i,j+1,k+1); c111=v(i+1,j+1,k+1)
   uy = trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)

   c000=w(i,j,k);   c100=w(i+1,j,k);   c010=w(i,j+1,k);   c110=w(i+1,j+1,k)
   c001=w(i,j,k+1); c101=w(i+1,j,k+1); c011=w(i,j+1,k+1); c111=w(i+1,j+1,k+1)
   uz = trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)

   c000=rho(i,j,k);   c100=rho(i+1,j,k);   c010=rho(i,j+1,k);   c110=rho(i+1,j+1,k)
   c001=rho(i,j,k+1); c101=rho(i+1,j,k+1); c011=rho(i,j+1,k+1); c111=rho(i+1,j+1,k+1)
   dens = trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)
end subroutine interpolate_velocity

end module mod_turbines
