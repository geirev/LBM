!==============================================================
!  mod_turbines.F90
!  Global turbine types, parameters and shared arrays
!==============================================================
module mod_turbines
   use mod_dimensions, only : nx, ny, nz, nyg
#ifdef MPI
   use mpi
   use m_mpi_decomp_init, only : mpi_rank, mpi_nprocs, j_start, j_end
#endif
   use mod_nrel5mw,   only : nrchords, relm, dc, chord, nfoil, twist, hubradius, rotorradius

   implicit none

   !-----------------------------------------------------------
   ! Mathematical constants
   !-----------------------------------------------------------
   real, parameter :: pi  = 3.14159265358979323846
   real, parameter :: pi2 = 2.0*pi

   !-----------------------------------------------------------
   ! Turbine type:
   !   Stores NREL-5MW style configuration information.
   !-----------------------------------------------------------
   type turbine_t
      real    :: xhub             ! hub x-position (global grid index)
      real    :: yhub             ! hub y-position (global grid index)
      real    :: zhub             ! hub z-position (global grid index)

      real    :: radius           ! rotor radius (non-dimensional, /p2l%length)
      integer :: iradius          ! rotor radius in number of grid cells

      integer :: nblades          ! number of blades
      integer :: nchords          ! chords per blade

      real    :: relm(nrchords)   ! radial positions (non-dimensional)
      real    :: dc   (nrchords)  ! radial segment length (non-dimensional)
      real    :: chord(nrchords)  ! chord width (non-dimensional)
      real    :: twist(nrchords)  ! twist angle per chord (deg)
      integer :: nfoil(nrchords)  ! foil index

      real    :: theta            ! rotor azimuth (rad)
      real    :: yaw              ! yaw angle (rad)
      real    :: tilt             ! tilt angle (rad)

      real    :: omegand          ! non-dim angular speed, omega*p2l%time
      real    :: pitchangle       ! collective pitch (deg)
      integer :: tiploss          ! tip-loss flag
   end type turbine_t

   !-----------------------------------------------------------
   ! point_t:
   !   One actuator sample point per chord per blade per turbine
   !   in global coordinates.
   !-----------------------------------------------------------
   type :: point_t
      integer :: iturb            ! turbine index
      integer :: iblade           ! blade index
      integer :: ichord           ! chord index

      real    :: xg, yg, zg       ! global coordinates (in grid units)
      real    :: dc               ! local radial segment
      real    :: chord            ! local chord width
      real    :: relm             ! local radial position
      integer :: foil             ! foil index
      real    :: twist            ! local twist (deg)
      real    :: yaw, tilt        ! yaw/tilt (rad)
      real    :: theta            ! rotor azimuth (rad)
      real    :: pitch            ! pitch (deg)
      real    :: omegand          ! non-dim angular speed
   end type point_t

   !-----------------------------------------------------------
   ! Global storage (used by high-level drivers if desired)
   !-----------------------------------------------------------
   type(turbine_t), allocatable :: turbines(:)
   type(point_t),   allocatable :: points_global(:)

   ! Storage for forcing on lattice nodes (optional helper)
   real                         :: F_turb(3,0:nx+1,0:ny+1,0:nz+1)
   real,            allocatable :: Fvec_local(:,:)   ! (3, np)
   real,            allocatable :: Fvec_global(:,:)  ! (3, np)

   integer :: ierr

end module mod_turbines


!==============================================================
!  m_turbine_init.F90
!  Turbine initialization: read config and fill turbines(:)
!==============================================================
module m_turbine_init
   use mod_turbines
   use m_readinfile, only : nturbines, p2l, ipos, jpos, kpos, turbrpm, pitchangle, tipspeedratio, itiploss
   use m_nrelreadfoil
   implicit none
contains

!--------------------------------------------------------------
!  subroutine turbine_initialize
!
!  PURPOSE:
!    Allocate and initialize the global array turbines(:)
!    using the configuration from m_readinfile and NREL-5MW
!    geometry from mod_nrel5mw.
!
!  CALL:
!    call turbine_initialize()
!
!  SIDE EFFECTS:
!    - Allocates mod_turbines::turbines(:)
!    - Calls nrelreadfoil() to load airfoil tables
!--------------------------------------------------------------
subroutine turbine_initialize()
   implicit none
   integer :: n
   real    :: radius, omega

   if (.not. allocated(turbines))  allocate(turbines(nturbines))

   ! Rotation speed in radians / second
   omega = pi2 * turbrpm / 60.0

   do n = 1, nturbines
      ! Hub position in global grid indices
      turbines(n)%xhub = real(ipos(n))
      turbines(n)%yhub = real(jpos(n))
      turbines(n)%zhub = real(kpos(n))

      ! Rotor geometry (non-dimensionalized by p2l%length)
      radius              = rotorradius + hubradius
      turbines(n)%radius  = radius / p2l%length
      turbines(n)%iradius = nint(turbines(n)%radius)

      print '(a,f8.2,i4)', 'Rotor radius=   ', turbines(n)%radius,  turbines(n)%iradius
      print '(a,f8.2)',    'Rotor diameter=', 2.0 * turbines(n)%radius

      ! Blade discretization
      turbines(n)%nblades = 3
      turbines(n)%nchords = nrchords

      turbines(n)%relm(1:)  = relm(1:)   / p2l%length
      turbines(n)%dc  (1:)  = dc  (1:)   / p2l%length
      turbines(n)%chord(1:) = chord(1:)  / p2l%length
      turbines(n)%twist(1:) = twist(1:)
      turbines(n)%nfoil(1:) = nfoil(1:)

      ! Orientation & dynamics
      turbines(n)%theta      = 0.0
      turbines(n)%yaw        = 0.0
      turbines(n)%tilt       = 0.0
      turbines(n)%omegand    = omega * p2l%time
      turbines(n)%pitchangle = pitchangle
      turbines(n)%tiploss    = itiploss
   end do

   print *, 'iradius =', turbines(1)%iradius

   ! Load airfoil tables for all foils used
   call nrelreadfoil()
end subroutine turbine_initialize

end module m_turbine_init


!==============================================================
!  m_turbine_interp.F90
!  Velocity & density interpolation (CPU/GPU unified)
!==============================================================
module m_turbine_interp
   use mod_dimensions, only : nx, ny, nz
   use mod_turbines,   only : pi
   implicit none
contains

!--------------------------------------------------------------
!  function turbine_trilinear
!
!  PURPOSE:
!    Trilinear interpolation of a scalar given its 8 corner
!    values and local fractional offsets fx, fy, fz.
!
!  NOTE:
!    Marked host/device so it can be called from both CPU and
!    CUDA kernels.
!--------------------------------------------------------------
#ifdef _CUDA
attributes(host,device) &
#endif
real function turbine_trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)
   implicit none
   real, intent(in) :: c000,c100,c010,c110,c001,c101,c011,c111
   real, intent(in) :: fx,fy,fz

   turbine_trilinear = c000*(1-fx)*(1-fy)*(1-fz) + c100*fx*(1-fy)*(1-fz) + &
                       c010*(1-fx)*fy*(1-fz)     + c110*fx*fy*(1-fz)     + &
                       c001*(1-fx)*(1-fy)*fz     + c101*fx*(1-fy)*fz     + &
                       c011*(1-fx)*fy*fz         + c111*fx*fy*fz
end function turbine_trilinear


!--------------------------------------------------------------
!  subroutine turbine_interpolate_velocity
!
!  PURPOSE:
!    Trilinear interpolation of u, v, w, rho at a global
!    actuator point (xg, yg, zg). Works on both CPU and GPU.
!
!  ARGUMENTS:
!    u,v,w,rho : staggered fields on tile [0:nx+1,0:ny+1,0:nz+1]
!    xg,yg,zg  : global coordinates (in grid units)
!    j_start   : global j-index of local tile j=1
!    ux,uy,uz  : interpolated velocity components
!    dens      : interpolated density
!
!  NOTE:
!    - On CPU, j_start is from m_mpi_decomp_init or 1 if no MPI.
!    - On GPU, caller must pass the correct j_start.
!--------------------------------------------------------------
#ifdef _CUDA
attributes(host,device) &
#endif
subroutine turbine_interpolate_velocity(u,v,w,rho, xg,yg,zg, j_start, ux,uy,uz,dens)
   use mod_dimensions, only : nx, ny, nz
   implicit none

   real, intent(in) :: u  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: v  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: w  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: rho(0:nx+1,0:ny+1,0:nz+1)

   real, intent(in)  :: xg, yg, zg
   integer, value    :: j_start
   real, intent(out) :: ux, uy, uz, dens

   integer :: ig, jg, kg
   integer :: i, j, k
   real    :: fx, fy, fz
   real    :: c000,c100,c010,c110,c001,c101,c011,c111

   ! Global integer indices
   ig = floor(xg)
   jg = floor(yg)
   kg = floor(zg)

   ! Fractional offsets
   fx = xg - real(ig)
   fy = yg - real(jg)
   fz = zg - real(kg)

   ! Global -> local tile index in j
   j = jg - j_start + 1
   i = ig
   k = kg

   ! Clamp into interior region
   i = max(1, min(nx-1, i))
   j = max(1, min(ny-1, j))
   k = max(1, min(nz-1, k))

   ! u
   c000=u(i,j,k);   c100=u(i+1,j,k);   c010=u(i,j+1,k);   c110=u(i+1,j+1,k)
   c001=u(i,j,k+1); c101=u(i+1,j,k+1); c011=u(i,j+1,k+1); c111=u(i+1,j+1,k+1)
   ux = turbine_trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)

   ! v
   c000=v(i,j,k);   c100=v(i+1,j,k);   c010=v(i,j+1,k);   c110=v(i+1,j+1,k)
   c001=v(i,j,k+1); c101=v(i+1,j,k+1); c011=v(i,j+1,k+1); c111=v(i+1,j+1,k+1)
   uy = turbine_trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)

   ! w
   c000=w(i,j,k);   c100=w(i+1,j,k);   c010=w(i,j+1,k);   c110=w(i+1,j+1,k)
   c001=w(i,j,k+1); c101=w(i+1,j,k+1); c011=w(i,j+1,k+1); c111=w(i+1,j+1,k+1)
   uz = turbine_trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)

   ! rho
   c000=rho(i,j,k);   c100=rho(i+1,j,k);   c010=rho(i,j+1,k);   c110=rho(i+1,j+1,k)
   c001=rho(i,j,k+1); c101=rho(i+1,j,k+1); c011=rho(i,j+1,k+1); c111=rho(i+1,j+1,k+1)
   dens = turbine_trilinear(c000,c100,c010,c110,c001,c101,c011,c111,fx,fy,fz)
end subroutine turbine_interpolate_velocity

end module m_turbine_interp


!==============================================================
!  m_turbine_bladeforce.F90
!  Rotor basis and blade force projection (CPU/GPU unified)
!==============================================================
module m_turbine_bladeforce
   use mod_turbines, only : point_t
   implicit none
contains

!--------------------------------------------------------------
!  subroutine turbine_rotor_basis
!
!  PURPOSE:
!    Build orthonormal basis for the rotor:
!      e_axis : rotor axis (unit)
!      e1, e2 : in-plane orthonormal vectors
!
!  yaw  : rotation about z-axis
!  tilt : pitch of rotor axis
!--------------------------------------------------------------
#ifdef _CUDA
attributes(host,device) &
#endif
subroutine turbine_rotor_basis(yaw, tilt, e_axis, e1, e2)
   implicit none
   real, intent(in)  :: yaw, tilt
   real, intent(out) :: e_axis(3), e1(3), e2(3)

   e_axis = (/ cos(yaw)*cos(tilt),  sin(yaw)*cos(tilt), -sin(tilt) /)
   e1     = (/ -sin(yaw),           cos(yaw),            0.0       /)
   e2     = (/ -cos(yaw)*sin(tilt), -sin(yaw)*sin(tilt), -cos(tilt) /)
end subroutine turbine_rotor_basis


!--------------------------------------------------------------
!  subroutine turbine_compute_blade_force
!
!  PURPOSE:
!    Given axial and tangential relative velocities (u_ax,
!    u_tan_rel) in the rotor plane, plus cl/cd, compute the
!    3D force vector on the blade section in global coordinates.
!
!  ARGUMENTS:
!    point      : point_t containing geometry + orientation
!    u_ax       : axial component of relative velocity
!    u_tan_rel  : tangential component (Ω r - tangential flow)
!    dens       : local fluid density
!    cl, cd     : lift & drag coefficients
!    Fvec(3)    : resulting force vector (global x,y,z)
!--------------------------------------------------------------
#ifdef _CUDA
attributes(host,device) &
#endif
subroutine turbine_compute_blade_force(Fvec, point, u_ax, u_tan_rel, dens, cl, cd)
   implicit none
   type(point_t), intent(in) :: point
   real, intent(in)          :: u_ax, u_tan_rel
   real, intent(in)          :: dens
   real, intent(in)          :: cl, cd
   real, intent(out)         :: Fvec(3)

   real :: e_axis(3), e1(3), e2(3)
   real :: e_rot(3), e_tan(3)
   real :: speed2, area, L, D
   real :: phi, sinphi, cosphi
   real :: tiploss

   ! Build rotor coordinate system
   call turbine_rotor_basis(point%yaw, point%tilt, e_axis, e1, e2)

   ! Radial and tangential directions
   e_rot =  cos(point%theta)*e1 + sin(point%theta)*e2
   e_tan = -sin(point%theta)*e1 + cos(point%theta)*e2

   ! Relative speed squared in rotor plane
   speed2 = u_ax*u_ax + u_tan_rel*u_tan_rel

   ! Chord area
   area   = point%chord * point%dc

   ! Tip-loss factor (placeholder)
   tiploss = 1.0

   L = 0.5 * dens * speed2 * cl * area * tiploss
   D = 0.5 * dens * speed2 * cd * area * tiploss

   ! Flow angle
   phi    = atan2(u_ax, u_tan_rel)
   sinphi = sin(phi)
   cosphi = cos(phi)

   ! Lift and drag decomposition in (e_axis, e_tan) plane
   Fvec = L * (cosphi * e_axis + sinphi * e_tan) - &
          D * (sinphi * e_axis - cosphi * e_tan)
end subroutine turbine_compute_blade_force

end module m_turbine_bladeforce


!==============================================================
!  m_turbine_extend.F90
!  Small utility to grow allocatable arrays of point_t
!==============================================================
module m_turbine_extend
   use mod_turbines, only : point_t
   implicit none
contains

!--------------------------------------------------------------
!  subroutine turbine_extend_array
!
!  PURPOSE:
!    Grow an allocatable array of point_t to size n.
!
!  NOTE:
!    Copies existing data and move_allocs to original.
!--------------------------------------------------------------
subroutine turbine_extend_array(arr, n)
   type(point_t), allocatable, intent(inout) :: arr(:)
   integer,           intent(in)            :: n

   type(point_t), allocatable :: tmp(:)
   integer :: old

   if (.not. allocated(arr)) then
      allocate(arr(n))
   else
      allocate(tmp(n))
      old = size(arr)
      tmp(1:old) = arr(1:old)
      call move_alloc(tmp, arr)
   end if
end subroutine turbine_extend_array

end module m_turbine_extend


!==============================================================
!  m_turbine_points.F90
!  Construct actuator points and compute point forces (CPU/GPU)
!==============================================================
module m_turbine_points
   use mod_turbines
   use m_turbine_extend
   use m_turbine_interp
   use m_turbine_bladeforce
   use m_nrelliftdrag
#ifdef MPI
   use m_mpi_decomp_init, only : j_start, j_end, mpi_rank
#endif
#ifdef _CUDA
   use cudafor
#endif
   implicit none
contains

!--------------------------------------------------------------
!  subroutine turbine_distribute_points
!
!  PURPOSE:
!    Build the global list of actuator sample points
!    (points_global) from turbine hub locations and blade
!    geometry.
!
!  CALL:
!    call turbine_distribute_points(turbines, points_global)
!--------------------------------------------------------------
subroutine turbine_distribute_points(turbines_in, points_global)
   type(turbine_t),            intent(in)  :: turbines_in(:)
   type(point_t),   allocatable, intent(out) :: points_global(:)

   integer :: it, ib, ic
   integer :: np_local
   real    :: e_axis(3), e1(3), e2(3), e_rot(3)
   real    :: theta, yaw, tilt
   type(point_t) :: pt

   allocate(points_global(0))
   np_local = 0

   do it = 1, size(turbines_in)
      yaw  = turbines_in(it)%yaw
      tilt = turbines_in(it)%tilt

      call turbine_rotor_basis(yaw, tilt, e_axis, e1, e2)

      do ib = 1, turbines_in(it)%nblades
         theta = turbines_in(it)%theta + real(ib-1)*pi2/real(turbines_in(it)%nblades)

         do ic = 1, turbines_in(it)%nchords
            pt%iturb  = it
            pt%iblade = ib
            pt%ichord = ic

            e_rot = cos(theta)*e1 + sin(theta)*e2

            pt%xg = turbines_in(it)%xhub + turbines_in(it)%relm(ic) * e_rot(1)
            pt%yg = turbines_in(it)%yhub + turbines_in(it)%relm(ic) * e_rot(2)
            pt%zg = turbines_in(it)%zhub + turbines_in(it)%relm(ic) * e_rot(3)

            pt%yaw     = yaw
            pt%tilt    = tilt
            pt%theta   = theta
            pt%relm    = turbines_in(it)%relm(ic)
            pt%dc      = turbines_in(it)%dc(ic)
            pt%chord   = turbines_in(it)%chord(ic)
            pt%twist   = turbines_in(it)%twist(ic)
            pt%pitch   = turbines_in(it)%pitchangle
            pt%foil    = turbines_in(it)%nfoil(ic)
            pt%omegand = turbines_in(it)%omegand

            call turbine_extend_array(points_global, np_local+1)
            np_local = np_local + 1
            points_global(np_local) = pt
         end do
      end do
   end do
end subroutine turbine_distribute_points


!--------------------------------------------------------------
!  subroutine turbine_point_forces
!
!  PURPOSE:
!    CPU version: for each actuator point, interpolate local
!    flow, compute angle of attack, cl/cd, and resulting
!    force vector.
!
!  CALL:
!    call turbine_point_forces(points_global, rho, u, v, w, Fvec_local, np)
!--------------------------------------------------------------
subroutine turbine_point_forces(points_global, rho, u, v, w, Fvec_local, np)
   use mod_dimensions, only : nx, ny, nz
   implicit none
   type(point_t), intent(in) :: points_global(:)
   real, intent(in)          :: rho(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in)          :: u  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in)          :: v  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in)          :: w  (0:nx+1,0:ny+1,0:nz+1)
   integer, intent(in)       :: np
   real,    intent(out)      :: Fvec_local(3, np)

   integer :: p, j0
   real :: ux, uy, uz, dens
   real :: angattack, clift, cdrag
   real :: costheta, sintheta
   real :: utheta, phi
   integer :: my_j_start

   Fvec_local = 0.0

#ifdef MPI
   my_j_start = j_start
#else
   my_j_start = 1
#endif

   do p = 1, np
      j0 = floor(points_global(p)%yg)
#ifdef MPI
      if (j0 < j_start .or. j0 > j_end) cycle
#endif

      call turbine_interpolate_velocity(u, v, w, rho, &
           points_global(p)%xg, points_global(p)%yg, points_global(p)%zg, &
           my_j_start, ux, uy, uz, dens)

      costheta = cos(points_global(p)%theta)
      sintheta = sin(points_global(p)%theta)

      ! Tangential relative velocity (Ω r - projection of flow)
      utheta = points_global(p)%omegand * points_global(p)%relm - &
               uz*costheta - uy*sintheta

      phi       = atan2(ux, utheta)
      angattack = (phi*180.0/pi - points_global(p)%twist - points_global(p)%pitch)

      call nrelliftdrag(clift, cdrag, angattack, points_global(p)%foil)

      call turbine_compute_blade_force(Fvec_local(:,p), points_global(p), ux, utheta, dens, clift, cdrag)
   end do
end subroutine turbine_point_forces


!--------------------------------------------------------------
!  subroutine turbine_point_forces_gpu
!
!  PURPOSE:
!    GPU wrapper: allocate device arrays for points and Fvec,
!    launch CUDA kernel over points, then copy forces back.
!--------------------------------------------------------------
#ifdef _CUDA
subroutine turbine_point_forces_gpu(points_global, rho, u, v, w, Fvec_local, np)
   use mod_dimensions, only : nx, ny, nz
#ifdef MPI
   use m_mpi_decomp_init, only : j_start, j_end
#else
   integer, parameter :: j_start = 1, j_end = ny
#endif
   implicit none

   type(point_t), intent(in) :: points_global(:)
   real, intent(in)          :: rho(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in)          :: u  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in)          :: v  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in)          :: w  (0:nx+1,0:ny+1,0:nz+1)
   integer, intent(in)       :: np
   real, intent(out)         :: Fvec_local(3, np)

   type(point_t), device, allocatable :: points_d(:)
   real,          device, allocatable :: Fvec_d(:,:)

   integer :: tpb, nblocks, istat

   if (np <= 0) then
      Fvec_local = 0.0
      return
   end if

   allocate(points_d(np))
   points_d = points_global

   allocate(Fvec_d(3,np))
   Fvec_d = 0.0

   tpb     = 128
   nblocks = (np + tpb - 1) / tpb

   call turbine_point_forces_kernel<<<nblocks, tpb>>> &
        (points_d, np, rho, u, v, w, j_start, j_end, Fvec_d)

   istat = cudaDeviceSynchronize()

   Fvec_local = Fvec_d

   deallocate(points_d, Fvec_d)
end subroutine turbine_point_forces_gpu
#endif  /* _CUDA */


!--------------------------------------------------------------
!  subroutine turbine_point_forces_kernel
!
!  PURPOSE:
!    CUDA kernel: one thread per actuator point. Interpolates
!    local flow, computes AoA, cl/cd, and final force vector.
!--------------------------------------------------------------
#ifdef _CUDA
attributes(global) &
#endif
subroutine turbine_point_forces_kernel(points, np, rho, u, v, w, j_start, j_end, Fvec)
   use mod_dimensions, only : nx, ny, nz
   implicit none

   type(point_t) :: points(:)
   integer, value :: np
   real :: rho(0:nx+1,0:ny+1,0:nz+1)
   real :: u  (0:nx+1,0:ny+1,0:nz+1)
   real :: v  (0:nx+1,0:ny+1,0:nz+1)
   real :: w  (0:nx+1,0:ny+1,0:nz+1)
   integer, value :: j_start, j_end
   real :: Fvec(3, np)

   integer :: p, j0
   real :: ux, uy, uz, dens
   real :: angattack, clift, cdrag
   real :: costheta, sintheta
   real :: utheta, phi

#ifdef _CUDA
   p = (blockIdx%x - 1) * blockDim%x + threadIdx%x
#else
   p = 0
#endif
   if (p < 1 .or. p > np) return

   j0 = floor(points(p)%yg)
   if (j0 < j_start .or. j0 > j_end) then
      Fvec(1,p) = 0.0
      Fvec(2,p) = 0.0
      Fvec(3,p) = 0.0
      return
   end if

   call turbine_interpolate_velocity(u, v, w, rho, &
        points(p)%xg, points(p)%yg, points(p)%zg, j_start, ux, uy, uz, dens)

   costheta = cos(points(p)%theta)
   sintheta = sin(points(p)%theta)

   utheta = points(p)%omegand * points(p)%relm - &
            uz*costheta - uy*sintheta

   phi       = atan2(ux, utheta)
   angattack = (phi*180.0/pi - points(p)%twist - points(p)%pitch)

   call nrelliftdrag(clift, cdrag, angattack, points(p)%foil)

   call turbine_compute_blade_force(Fvec(:,p), points(p), ux, utheta, dens, clift, cdrag)
end subroutine turbine_point_forces_kernel

end module m_turbine_points


!==============================================================
!  m_turbine_deposit.F90
!  Deposit smoothed actuator forces on the lattice
!==============================================================
module m_turbine_deposit
   use mod_turbines
   use mod_dimensions, only : nx, ny, nz, nyg
#ifdef MPI
   use m_mpi_decomp_init, only : j_start, j_end
#endif
   implicit none
contains

!--------------------------------------------------------------
!  subroutine turbine_deposit
!
!  PURPOSE:
!    Deposit global point forces Fvec_global onto the
!    tile-local forcing field F_turb using a Gaussian stencil.
!
!  CALL:
!    call turbine_deposit(F_turb, points_global, Fvec_global, np)
!--------------------------------------------------------------
subroutine turbine_deposit(F_turb, points_global, Fvec_global, np)
   real,          intent(inout) :: F_turb(3,0:nx+1,0:ny+1,0:nz+1)
   integer,       intent(in)    :: np
   type(point_t), intent(in)    :: points_global(np)
   real,          intent(in)    :: Fvec_global(3, np)

   integer :: p, i0, j0, k0
   integer :: ii, jj, kk
   integer :: ii1, ii2, jj1g, jj2g, kk1, kk2
   integer :: jj_local
   real    :: dx, dy, dz, weight, sumW
   real    :: sigma, epsilon
   real    :: xg, yg, zg
   real    :: Fp(3)
   integer :: krad

   epsilon = 2.0
   sigma   = epsilon / sqrt(2.0)
   krad    = ceiling(3.0 * sigma)

   do p = 1, np
      xg = points_global(p)%xg
      yg = points_global(p)%yg
      zg = points_global(p)%zg

      Fp(:) = Fvec_global(:,p)
      if (Fp(1) == 0.0 .and. Fp(2) == 0.0 .and. Fp(3) == 0.0) cycle

      i0 = floor(xg)
      j0 = floor(yg)
      k0 = floor(zg)

      ii1  = max(1,   i0 - krad)
      ii2  = min(nx,  i0 + krad)
      jj1g = max(1,   j0 - krad)
      jj2g = min(nyg, j0 + krad)
      kk1  = max(1,   k0 - krad)
      kk2  = min(nz,  k0 + krad)

      sumW = 0.0
      do kk = kk1, kk2
         dz = real(kk) - zg
         do jj = jj1g, jj2g
            dy = real(jj) - yg
            do ii = ii1, ii2
               dx = real(ii) - xg
               sumW = sumW + exp(-(dx*dx + dy*dy + dz*dz)/(2.0*sigma*sigma))
            end do
         end do
      end do

      if (sumW < 1.0e-6) cycle

      do kk = kk1, kk2
         dz = real(kk) - zg
         do jj = jj1g, jj2g
#ifdef MPI
            if (jj < j_start .or. jj > j_end) cycle
            jj_local = jj - j_start + 1
#else
            jj_local = jj
#endif
            if (jj_local < 1 .or. jj_local > ny) cycle

            dy = real(jj) - yg

            do ii = ii1, ii2
               dx = real(ii) - xg

               weight = exp(-(dx*dx + dy*dy + dz*dz)/(2.0*sigma*sigma)) / sumW

               F_turb(1,ii,jj_local,kk) = F_turb(1,ii,jj_local,kk) + weight*Fp(1)
               F_turb(2,ii,jj_local,kk) = F_turb(2,ii,jj_local,kk) + weight*Fp(2)
               F_turb(3,ii,jj_local,kk) = F_turb(3,ii,jj_local,kk) + weight*Fp(3)
            end do
         end do
      end do
   end do
end subroutine turbine_deposit

end module m_turbine_deposit


!==============================================================
!  m_turbine_forcing.F90
!  High-level driver to compute turbine forcing on each tile
!==============================================================
module m_turbine_forcing
   use mod_turbines
   use m_turbine_points
   use m_turbine_deposit
   use m_wtime
#ifdef MPI
   use m_mpi_decomp_init, only : j_start, j_end, mpi_rank
#endif
#ifdef _CUDA
   use cudafor
#endif
   implicit none
contains

!--------------------------------------------------------------
!  subroutine turbine_compute_forcing
!
!  PURPOSE:
!    High-level driver called from the main LBM time loop.
!    For each step:
!      1) Update rotor azimuth theta
!      2) Rebuild global actuator points
!      3) Compute per-point forces (CPU or GPU)
!      4) MPI_Allreduce to accumulate tile contributions
!      5) Deposit smoothed forces on local F_turb
!
!  CALL:
!    call turbine_compute_forcing(F_turb, turbines, rho, u, v, w)
!--------------------------------------------------------------
subroutine turbine_compute_forcing(F_turb_local, turbines_in, rho, u, v, w)
   use mod_dimensions, only : nx, ny, nz
   implicit none

   ! Output forcing field on this tile
   real, intent(inout)            :: F_turb_local(3,0:nx+1,0:ny+1,0:nz+1)

   ! Turbine configuration (can be same as mod_turbines::turbines)
   type(turbine_t), intent(inout) :: turbines_in(:)

   ! Flow fields (tile-local storage; often device arrays under CUDA)
   real, intent(in) :: rho(0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: u  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: v  (0:nx+1,0:ny+1,0:nz+1)
   real, intent(in) :: w  (0:nx+1,0:ny+1,0:nz+1)
#ifdef _CUDA
   attributes(device) :: rho,u,v,w
#endif

   integer :: np_local
   real, allocatable :: rho_h(:,:,:), u_h(:,:,:), v_h(:,:,:), w_h(:,:,:)

   call cpustart()

   ! 1. Update turbine azimuth
   turbines_in(:)%theta = turbines_in(:)%theta + turbines_in(:)%omegand

   ! 2. Construct global actuator points
   if (allocated(points_global)) deallocate(points_global)
   call turbine_distribute_points(turbines_in, points_global)
   np_local = size(points_global)

   if (np_local == 0) then
      F_turb_local = 0.0
      return
   end if

   ! 3. Allocate global force vectors in mod_turbines
   if (allocated(Fvec_local))  deallocate(Fvec_local)
   if (allocated(Fvec_global)) deallocate(Fvec_global)
   allocate(Fvec_local(3, np_local))
   allocate(Fvec_global(3, np_local))
   Fvec_local  = 0.0
   Fvec_global = 0.0

   call cpufinish(21)

   call cpustart()
#ifdef _CUDA
   ! 4. GPU path: compute point forces directly on device
   call turbine_point_forces_gpu(points_global, rho, u, v, w, Fvec_local, np_local)
#else
   ! 4. CPU path: copy fields and compute on host
   allocate(rho_h(0:nx+1,0:ny+1,0:nz+1))
   allocate(u_h  (0:nx+1,0:ny+1,0:nz+1))
   allocate(v_h  (0:nx+1,0:ny+1,0:nz+1))
   allocate(w_h  (0:nx+1,0:ny+1,0:nz+1))

   rho_h = rho
   u_h   = u
   v_h   = v
   w_h   = w

   call turbine_point_forces(points_global, rho_h, u_h, v_h, w_h, Fvec_local, np_local)

   deallocate(rho_h, u_h, v_h, w_h)
#endif
   call cpufinish(22)

   call cpustart()
#ifdef MPI
   ! 5. MPI reduction: sum contributions from all tiles
   call MPI_Allreduce(Fvec_local, Fvec_global, 3*np_local, MPI_REAL, MPI_SUM, MPI_COMM_WORLD, ierr)
#else
   Fvec_global = Fvec_local
#endif
   call cpufinish(23)

   call cpustart()
   ! 6. Clear local forcing field and deposit smoothed forces
   F_turb_local = 0.0

   call turbine_deposit(F_turb_local, points_global, Fvec_global, np_local)

   deallocate(Fvec_local, Fvec_global)
   deallocate(points_global)

   call cpufinish(24)
end subroutine turbine_compute_forcing

end module m_turbine_forcing
